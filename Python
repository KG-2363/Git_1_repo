Python --

When we take input from the console using input function, the default type is string. We need to convert the type if we need to
use as diff datatype.
x = input("Enter first number")
print(type(x)) -- class str

-- replace function in python 
str1 = "my name is govind"
new_str1 = str1.replace(" ","_")

cols_list = df.columns -- returns a list of columns in df, not a function
new_cols_list = []
for col in cols:
  new_col = col.replace(" ","_").lower()
  new_cols_list.append(new_col)
print(new_cols)

-- In Pyspark 
cols = df.columns
for col in cols:
  new_col = col.replace(" ","_").lower()
  df = df.withColumnRenamed(col,new_col)



Basic functions in Python --

1. Map -- It takes a function and a list as an argument. It returns an iterator, not a list.
You need to consume the iterator (e.g., with list(), for loop, etc.) to see the actual values.
This design is intentional for performance and memory efficiency.

An iterator in Python is an object that represents a stream of data. 
You can loop through it, but it doesn't hold all the data in memory at once. Instead, it generates each item on demand.

list1 = [1,2,3,4]
a = map(lambda x: (x,1),list1)
print(a) -- map object at a0xx
print(list(a)) -- [ (1,1),(2,1)..]

2. Split -- The split() function in Python is used to divide a string into a list of substrings based on a specified delimiter.
The output is a list.
sentence = "A black browm fox jumps over a lazy dog"
words = sentence.split()
print(words)
['A', 'black', 'browm', 'fox', 'jumps', 'over', 'a', 'lazy', 'dog']

3. Reduce - The reduce takes a function and a list as an input and returns a reduced output. 
from functools import reduce
list1 =[1,2,3,4]
b= reduce(lambda x,y : x*y,list1)
print(b) --24
print(type(b)) --class int

4. Filter --The filter() function in Python takes in a function and a list as arguments. Returns a list
This offers an elegant way to filter out all the elements of a sequence "sequence", for which the function returns True.
a = [1,2,3,4,5]
even = filter(lambda x : x%2 ==0, a)
print(list(even))
[2,4]

5. iloc stands for integer-location based indexing.It is used to select rows and columns by their index numbers not by labels.
select rows --  df.iloc[1] ; df.iloc[0,2] ; 
select cols --  df.iloc[:,1] all rows column index 1 ; df.iloc[0:2, 1:3] ; 

6. Regex for camel case to snake case -- replaces with group1 + underscore + group2
import re 
column_name = "customerIdnumber"
snake_case = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2',column_name).lower()
print(snake_case)

7.The any() function in Python is a built-in function that returns True if any element of an iterable is True.
Otherwise, it returns False. The iterable can be a list, tuple, set, generator, etc.
It checks each element: if at least one is True, it returns True.

import os
files = ['file1.txt', 'file2.txt', 'file3.txt']
if any(os.path.exists(f) for f in files):
    print("At least one file exists.")

numbers = [-1, -2, 0, 3]
if any(n > 0 for n in numbers):
    print("There is a positive number.")

numbers = [2, 7, 10, 13]
if any(n % 5 == 0 for n in numbers):
    print("At least one number is divisible by 5.")

-- Why Use any()?
Cleaner and more readable than writing a loop with if and break.
Efficient: stops checking as soon as it finds a True.

8. All function - 
fields = ["name", "phone", "email"]
if all(field != "" for field in fields):
    print("All fields are fill


numbers = [1, 2, 3]
if all(n > 0 for n in numbers):
    print("All numbers are positive.")


password = "Secure123!"
special_chars = "!@#$%^&*()"
has_special = any(char in special_chars for char in password)
has_digit = any(char.isdigit() for char in password)
has_upper = any(char.isupper() for char in password)

if all([has_special, has_digit, has_upper]):
    print("Strong password.")
else:
    print("Weak password.")




==================================================
## LIST 
Accessing elements of a List #

# Use Case	              # Method
Access a specific item	  list[index]
Loop through all items	  for item in list:
Need index and value	  for i, item in enumerate(list):
Filter items	          Use if inside loop

#Method	           #Description	                             #Example
append(x)	       Adds an item to the end	                 fruits.append("orange")
extend(iterable)   Adds all items from another list	         fruits.extend(["grape", "melon"])
insert(i, x)	   Inserts item at index i	                 fruits.insert(1, "kiwi")
remove(x)	       Removes first occurrence of x	         fruits.remove("banana")
pop([i])	       Removes and returns item at index i       fruits.pop()
                   (last if not given)	
clear()	           Removes all items	                     fruits.clear()
index(x)	       Returns index of first occurrence of x	 fruits.index("apple")
count(x)	       Counts how many times x appears	         fruits.count("apple")
sort()	           Sorts the list in place	                 fruits.sort()
reverse()	       Reverses the list in place	             fruits.reverse()
copy()	           Returns a shallow copy	                 new_list = fruits.copy()

fruits = ['apple', 'banana', 'cherry']
print(fruits[0])  # Output: apple
print(fruits[2])  # Output: cherry

for fruit in fruits:
    if 'a' in fruit:
        print(fruit)

for i, fruit in enumerate(fruits):
    print(f"Index {i}: {fruit}")
 # Output: apple
 # Output: banana

for i in range(len(fruits)):
    print(f"Index {i}: {fruits[i]}")


# pop() method ---------------------

Purpose: Removes an element by index and returns it.
Syntax: list.pop(index)
Default behavior: If no index is provided, it removes and returns the last element.
Raises: IndexError if the index is out of range.

‚úÖ Use cases:

When you need to extract and use an element from a specific position.
Useful in stack or queue implementations.

nums = [10, 20, 30, 40]
removed = nums.pop(2)  # Removes 30
print(removed)         # Output: 30
print(nums)            # Output: [10, 20, 40]


# remove() method --------------------

Purpose: Removes the first occurrence of a specific value.
Syntax: list.remove(value)
Raises: ValueError if the value is not found.

‚úÖ Use cases:

When you know the value to remove but not its index.
Useful for cleaning up duplicates or removing specific items.

nums = [10, 20, 30, 20, 40]
nums.remove(20)        # Removes the first 20
print(nums)            # Output: [10, 30, 20, 40]


Feature              pop()                 remove()
Removes by           Index                 Value
Returns value?       ‚úÖ Yes               ‚ùå No
Raises error         IndexError            ValueError
Use case             Extract by position   Delete by value
--------------------------------------------


üîπ list.extend(iterable)

Purpose: Adds each element of the iterable to the end of the list.
Modifies original list: ‚úÖ Yes
Returns: None
Example:
a = [1, 2]
b = [3, 4]
a.extend(b)
print(a)  # [1, 2, 3, 4]


üîπ list.append(item)

Purpose: Adds the item as a single element to the end of the list.
Modifies original list: ‚úÖ Yes
Returns: None
Example:
Pythona = [1, 2]
b = [3, 4]
a.append(b)
print(a)  # [1, 2, [3, 4]]


üîπ list1 + list2

Purpose: Concatenates two lists and returns a new list.
Modifies original list: ‚ùå No
Returns: New list
Example:
Pythona = [1, 2]
b = [3, 4]
c = a + b
print(c)  # [1, 2, 3, 4]
print(a)  # [1, 2] ‚Äî original list unchanged


-------------------------------------------------
# Move all zeros in a list to the end while maintaining the order of non-zero elements. 

[0, 1, 0, 3, 12] to [1, 3, 12, 0, 0]

list_nums = [0, 1, 0, 3, 12]
new_list_nums=[]
count = 0
for num in list_nums:
    if num != 0:
        new_list_nums.append(num)
    else:
        count +=1
for i in range(count):
    new_list_nums.append(0)
print(new_list_nums)

# Using List Comprehension  ----
[expression for item in iterable if condition]

new_list_nums = [num for num in list_nums if num != 0]
new_list_nums += [0] * list_nums.count(0)
print(new_list_nums)

===============================================================
## Sorted array
# Return True if the list is sorted USING FLAG
-- We are using break to come out of the for loop when the condition is met

nums = [1, 6, 3, 2, 9]
is_sorted = True
for i in range(1, len(nums)):
    if nums[i] <= nums[i - 1]:
        is_sorted = False
        break
print(is_sorted)

---------------------------
is sorted = True
for i in range(1, len(nums)):
     if nums[i-1] >= nums[i]:
         is_sorted = False
         break
print(is_sorted)

-----------------------------
--Using Recursion 
In the recursive step we are removing the first element and passing the new list/Array to the function.

def isArraySorted(A):
    if len(A)==1:
        return True
    return A[0] <= A[1] and isArraySorted(A[1:])


==================================================
## TUPLES -A tuple is an immutable, ordered collection of elements in Python. You define it using parentheses ().
Tuples use less memory than lists and are slightly faster for iteration.
#Feature	 #Tuple
Mutable	    ‚ùå No
Ordered	    ‚úÖ Yes
Methods	    count(), index()
Use Cases	Fixed data, function returns, dictionary keys, memory efficiency

#Operation	  #Example	          #Description
Indexing	    t[0]	              Access element by position
Slicing	      t[1:3]	            Get a sub-tuple
Length	      len(t)	            Number of elements
Membership	  2 in t	            Check if value exists
Iteration	    for x in t:	        Loop through elements
Nesting	      ((1, 2), (3, 4))    Tuples inside tuples

1. count(value) : Returns the number of times a value appears.
t = (1, 2, 2, 3)
t.count(2)  # Output: 2
2. index(value) : Returns the first index of the value.
t.index(3)  # Output: 3

print(t[0:2])  # Output: (1,2,2)

marks = (85, 90, 85, 92, 85)
1. print( marks.count(85))
2.count = 0
for mark in marks:
    if mark == 85:
        count +=1
print(count)

--Unpacking 
def get_user():
    return ("Govind", "Lead Data Engineer")
name, role = get_user()



==================================================
## DICTIONARY 

Method	                      Description	                                    Example
get(key, default)	          Returns value for key, or default if not found	employee.get("name", "Unknown")
keys()	                      Returns all keys	                                employee.keys()
values()	                  Returns all values	                            employee.values()
items()	                      Returns all key-value pairs as tuples	            employee.items()
update(dict)	              Adds or updates key-value pairs	                employee.update({"location": "Bengaluru"})
pop(key)	                  Removes key and returns its value	                employee.pop("role")
popitem()	                  Removes and returns last inserted key-value pair	employee.popitem()
clear()	                      Removes all items	                                employee.clear()
setdefault(key, default)	  Sets value if key not present                  	employee.setdefault("team", "Data")
copy()	                      Returns a shallow copy	                        new_emp = employee.copy()

# Basic Operations on Dictionary --

students = [
    {'name': 'Ravi', 'marks': 85},
    {'name': 'Anita', 'marks': 92},
    {'name': 'Kumar', 'marks': 78}
]

names = []
count = 0

# get method --

for student in students:
    if student.get('marks') > 80:
       names.append(student.get('name'))
       count += 1
print(set(names))
print(count)

# Items method --
--Returns a list of dict items having key and value pair as tuples

student1 = {'name': 'Ravi', 'age': 21, 'grade': 'A'}

student1_list = student1.items() --prints list of tuples having key and value
print(student1_list)
# dict_items([('name', 'Ravi'), ('age', 21), ('grade', 'A')])

# Print elements of dictionary as key : value --

for k,v in student1.items():
    print(f"{ k } : { v }")
# name : Ravi
age : 21
grade : A

# isinstance method -- checks the datatype 
if isinstance(v, str):
     print(v)
---------------------------------------------------
# Accessing elements of nested dictionaries 
-- Return the address having state as mh from the dict 

cust_details = {
    'name': 'hello',
    'id': '123',
    'address': [
        {'street': 'abc', 'city': 'bangalore', 'state': 'ka'},
        {'street': 'abc', 'city': 'mumbai', 'state': 'mh'}
    ]
}

# Loop through the list of addresses
for addr in cust_details['address']:
    if addr['state'] == 'mh':
        print(addr)
-------------------------------------------------
# adding two dictionaries
dict1 = {'Virat': 10, 'Sachin': 20, 'Dhoni': 30}
dict2 = {'Virat': 15, 'Smritika': 5, 'Dhoni': 25}

result_dict = dict1.copy()
for key,value in dict2.items():
    if key in result_dict:
        result_dict[key]+=value
    else:
        result_dict[key]=value
print(result_dict)
----------------------------------------------------

# dict(...) converts this list of tuples into a dictionary. But if a key appears multiple times, only the last occurrence is kept.
word = ['a','e','i','o','u','a','e','i','k']
list_words = dict(map(lambda x: (x,1), word))
print(list_words)
output --{'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'k': 1}
So 'a' appears twice, but only the last ('a', 1) is retained. Same for 'e' and 'i'.

-----------------------------------------------------

# Counting the frequency of words in a list and return a dict with word,count --
word = ['a','e','i','o','u','a','e','i','k']
list_words = {}

for char in word:
    if char in list_words:
        list_words[char] += 1
    else:
        list_words[char] = 1

print(list_words)

==================================================

## FUNCTIONS Scope Local and Global --

When we use a variable name, how does Python know where to find its value?

It uses the LEGB rule!
LEGB stands for Local, Enclosing, Global, Built-in. 
These are the possible scopes of a variable in Python. When we use a variable name in Python, it follows this sequence to find its value.

In Python, variables are stored in namespaces, which act as containers for mapping names to objects. When Python encounters a variable, it searches through different namespaces to find its value, following the LEGB rule.

L - Local:: Variables defined within the current function.

E - Enclosing: Variables in the local scope of any enclosing functions (for nested functions).

G - Global: Variables defined at the module level (outside any function or class).

B - Built-in: Names pre-defined in Python, such as len() or dict.

Python searches in the order Local ‚Üí Enclosing ‚Üí Global ‚Üí Built-in until it finds the variable. If the variable isn't found, it raises a NameError.





Global Variable Inside Function - Modification 
Read global variable	                   ‚úÖ Allowed without global keyword
Assign to global variable	               ‚ùå Not allowed unless declared with global
Assign inside function without global	   Python treats it as a new local variable

x = "global"
def fun():
    double = x * 2
    print(double)
fun() 

--x is defined outside the function, so it's a global variable. Inside fun(), you're readingx, not modifying it.
Python allows reading global variables inside functions without any special declaration. x * 2 just duplicates the string: "globalglobal"

x = "global"

def fun():
    x = x * 2
    print(x)

fun()

You're trying to assign to x inside the function: x = x * 2
Python treats any variable assigned inside a function as local by default.
So it thinks you're creating a new local variable x, but then tries to use its value (x * 2) before it's defined.
Since there's no local x yet, Python throws an UnboundLocalError.

x = "global"

def fun():
    global x
    x = x * 2
    print(x)

fun()
print(x)
# output --
globalglobal
globalglobal

When we declare with global keyword, it creates a local copy of the global variable.
the outer variable has been modified by the function.

----------------------------
üß† Meaning of nonlocal
The nonlocal keyword is used to refer to variables in the nearest enclosing scope (excluding the global scope). In this case:

x is defined in outer(), which is the enclosing function.
inner() is a nested function inside outer().
By declaring nonlocal x, you're telling Python:
‚ÄúDon‚Äôt treat x as a new local variable inside inner()‚Äîinstead, use the x from outer().‚Äù

üéØ Significance
Allows modification of outer function variables: Without nonlocal, x inside inner() would be treated as a new local variable, and the outer x would remain unchanged.
Useful in closures and decorators: It enables inner functions to retain and update state across multiple calls.
Avoids global scope pollution: Unlike global, nonlocal keeps the variable within the function hierarchy, making the code cleaner and safer.


x=10

def outer():
  x=20
  def inner():
      nonlocal x
      x=x+1
      print("inner x:",x)
  inner()
  print("Outer x:",x)
   
outer()
print("Global x:",x)

#Output --
inner x: 21
Outer x: 21
Global x: 10


-- global scope

x=10

def outer():
  x=20
  def inner():
      global x
      x=x+1
      print("inner x:",x)
  inner()
  print("Outer x:",x)
   
outer()
print("Global x:",x)

# Output --
inner x: 11
Outer x: 20
Global x: 11


locals and globals function --
-- We have defined locals inside outer function scope and globals outside. it shows the contents of the namespace -
-- inner function and x = 11

CASE 1 ------------------------------------------------------

x=10

def outer():
  x=20
  def inner():
      nonlocal x
      x=x+1
      print("inner x:",x)

  inner()
  print("Outer x:",x)
  print(locals())
   
outer()
print("Global x:",x)


print(globals())

# Output --

inner x: 21
Outer x: 21
{'inner': <function outer.<locals>.inner at 0x7894c57182c0>, 'x': 21}
Global x: 10
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {},
'__builtins__': <module 'builtins' (built-in)>, 
'traceback': <module 'traceback' from '/usr/local/lib/python3.12/traceback.py'>,
'x': 10, 'outer': <function outer at 0x7894c5718220>}


CASE 2 ------------------------------------------------------------

x=10

def outer():
  x=20
  def inner():
      global x
      x=x+1
      print("inner x:",x)

  inner()
  print("Outer x:",x)
  print(locals())
   
outer()
print("Global x:",x)


print(globals())

# Output --

inner x: 11
Outer x: 20
{'x': 20, 'inner': <function outer.<locals>.inner at 0x7e29754d02c0>}
Global x: 11
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {},
'__builtins__': <module 'builtins' (built-in)>, 
'traceback': <module 'traceback' from '/usr/local/lib/python3.12/traceback.py'>,
'x': 11, 'outer': <function outer at 0x7e29754d0220>}


--
x=1
def outer():
    x = 5
    def inner():
        nonlocal x
        x = 3 
        print(x)# modifies `x` in the enclosing `outer` function
    inner()
    print(x)  # prints 3
outer()
print(x)

#output --
3
3
1

x=1
def outer():
    x = 5
    def inner():
        global x
        x = 3 
        print(x)# modifies `x` in the enclosing `outer` function
    inner()
    print(x)  # prints 3
outer()
print(x)

#output --
3
5
3


Actions that create scope in Python:

Calling a function: Each function call creates a new local scope.
Accessing attributes or functions of a class: Class and instance scopes are created when you access or define functions within them.
Accessing objects in another module or package: Imported modules reside in the global scope of the importing module but create their own namespace, 
similar to calling a function.

Actions that DON‚ÄôT create scope in Python:

Entering an if statement: Variable assignments within an if block affect the current scope.
Entering a for or while loop: Variables defined within loops also stay in the current scope.
Creating a context manager (using with statements): These do not create a new scope either.


x = 10  # Global scope

def outer():
    global x
    x = 100  
    x_enclosed = 50# Enclosing scope
    def inner():
      nonlocal x_enclosed
      print(f"Inner x: {x_enclosed}")
    inner()

outer()
print(f"Global x: {x}")


Inner x: 50
Global x: 100
-----------------------------------------------------------------
ERROR AND EXCEPTION HANDLING --

There are two types of errors in Python 
1. Syntax error 
2. Exceptions

Syntax errors occur at compile time.
Exception occur at run time.

Try - the code which can produce errors.
Except - it handles the logic for catching the exception or error.
Else - It executes when the try block doesn't result into error.
Finally - It runs each time whether an exception occurs or not. It normally has the code for clean up of resources.

# Raise - Python provides a way to raise errors maunally when some conditions are not met.

# Custom exception --
The custom exception must extend the base exception class. 

class WrongEmailError(Exception):
    pass

try: 
   email = input("Enter the mail id: ")
   if '@' not in email:
       raise WrongEmailError("Please enter a valid mail id")
   
except WrongEmailError as e:
    print(e)
    
else:
    print("Your email id is: ",email)

finally:
    print("final thing ")

# Two custom errors --
# since the exception class already has self and msg arguments, super keyword uses the message from thye base class 
and overrides the message we have provided ourselves.

class InvalidAgeError(Exception): 
    def __init__(self,age):
        self.age = age
        super().__init__(f"Invalid age. {age} must be a positive integer.")

class InvalidEmailError(Exception): 
    def __init__(self,email):
        self.email = email
        super().__init__(f"Invalid email. {email} must be in the format username@gmail.com")

class Person:
    def __init__(self,name,age,email):
        self.name = name
        
        #validate age
        if age < 0:
            raise InvalidAgeError(age)
        self.age = age
        if '@' not in email or '.' not in email:
            raise InvalidEmailError(email)
        self.email = email

try:
    p1= Person("Govind", -29 ,'anksgmail.com')
except InvalidAgeError as e:
    print(e)
except InvalidEmailError as e:
    print(e)
else:
    print("Welcome ")
    



----------------------------------------------------------------------
## Reverse the list ( Using a third Variable )

list_nums = [12,12,34,55,67,88,89,85]
list_rev=[]

# Reverse List elements

-- Loop

def rev_list(nums):
    for i in range(len(nums)):
        list_rev.append(nums[-i])
rev_list(list_nums)
print(list_rev)

-- Slicing 

def rev_list(nums):
  return nums[::-1]
print(rev_list(list_nums))

## Sum of even numbers in a list

def even_sum(nums):
    even_nums=[]
    len_nums=len(nums)
    for i in range(len_nums):
        if nums[i]%2==0:
            even_nums.append(nums[i])
    return sum(even_nums)

even_sum(list_nums)

-- list comprehension usng lambda 

even_sum = lambda nums: sum(num for num in nums if num % 2 == 0)
even_sum(list_nums)

len_list = len(list_nums_1)

==================================================
# Remove duplicates from a list

-- Using set 

my_list = [1, 2, 2, 3, 4, 4, 5]
unique_list = list(set(my_list))
print(unique_list)

-- Using a loop (order preserved) (Unsorted & sorted )

my_list = [1, 2, 2, 3, 4, 4, 5]
unique_list = []
for item in my_list:
    if item not in unique_list:
        unique_list.append(item)
print(unique_list)

-- same list using count function & remove item 

nums =[1,1,2,3,3,34,4,4]
for num in nums:
    if nums.count(num)!= 1:
        nums.remove(num)
print(nums) 

-- Using a loop using pop (Works only for Sorted) 
-- beacuse we are comparing adjacent elements

def remove_dup(nums):
    i = 0
    while i < len(nums) - 1:
        if nums[i] == nums[i + 1]:
            nums.pop(i + 1)
        else:
            i += 1
    return nums

# Example usage
list_nums = [1, 2, 2, 3, 4, 4, 5]
print(remove_dup(list_nums))

-- Using dict.fromkeys() (order preserved, Python 3.7+)

my_list = [1, 2, 2, 3, 4, 4, 5]
unique_list = list(dict.fromkeys(my_list))
print(unique_list)

-- Using for loop but for is for iteration, manually incrementing values though

def remove_dup(nums):
    i = 0
    for _ in range(len(nums)):
        if i < len(nums) - 1:
            if nums[i] == nums[i + 1]:
                nums.pop(i + 1)
            else:
                i += 1
    return nums

-- Using recursion

def remove_dup_recursive(nums):
    if len(nums) < 2:
        return nums
    if nums[0] == nums[1]:
        return remove_dup_recursive(nums[1:])
    else:
        return [nums[0]] + remove_dup_recursive(nums[1:])

==================================================
## Square the elements of the list

def squared_nums(nums):
    squared_nums=[]
    for num in nums:
        squared_nums.append(num**2)
    return squared_nums
squared_nums(list_nums_1)


nums = [1,2,3,34,4,4]
sq_nums = [num**2 for num in nums]
print(sq_nums)


==================================================

## Rotate elements of the list by kth index --

list_1 = [1,2,3,4,5,6,7,8,9,10]
k=2

# Break the list in 2 parts at kth elements from last and then merge the list

def rotate_list(nums,k):
    list1 = nums[:len(nums)-k]
    list2 = nums[len(nums)-k:]
    return list2 + list1
rotate_list(list_1,k)


def rotate_list(nums,k):
    return nums[len(nums)-k:] + nums[:len(nums)-k]
rotate_list(list_1,k)

==================================================
## STRING Manipulation 

# Count the number of vowels in a given string.

word = 'AnkitaRiya'
def count_vowels(word):
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    count = 0
    for char in word:
        if char in vowels:
            count += 1
    return count
count_vowels(word)

-- Using list comprehension and sum 

def count_vowels(word):
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    count = 0
    count = sum(1 for char in word if char in vowels)
    return count


==================================================
# Reverse the string using slicing.

def rev_word(word):
   return word[::-1]

# Reverse the string without using slicing.
-- adding the ierable in the beginning of the new word adds the last element to the first

word = 'AnkitaRiya'
rev_word = ""
for char in word:
  rev_word = char + rev_word
   
print(rev_word)


word = 'AnkitaRiya'
def reverse_string(word1,word2):
    reversed_string=""
    reversed_string1=""
    print(word)
    for char in word:
        reversed_string = char + reversed_string
        reversed_string1 = reversed_string1 + char
    return reversed_string,reversed_string1

reverse_string(word,word)

==================================================

# Write a function to find the first non-repeating character in a string. If all characters repeat, return None.

def first_non_repeating_character(string):
    repeat_char=[]
    non_repeat_char=[]
    for char in string:
        if string.count(char) > 1:
            repeat_char.append(char)
        else:
            non_repeat_char.append(char)
    
    if len(non_repeat_char) == 0:
        return None
    else:
        return non_repeat_char[0]
    
first_non_repeating_character(word)


========================================================================================================================================================================================================
## Merging two dictionaries if key matches and as it is if doesn't match

dict1 = { 'key1' : 2000, 'key2' : 3000, 'key3' : 5000}
dict2 = { 'key1' : 1000, 'key2' : 2000}


def merge_dict(dict1,dict2):
  result_dict = dict1.copy()
  for k,v in dict2.items():
    if k in result_dict:
        result_dict[k] += v
    else:
        result_dict[k] = v
  return result_dict
a = merge_dict(dict1,dict2)

--------------------------------------------------------------

nums = [1,2,3,3,23,2,3,1]
def remove_dups(nums):
    set_nums = set(nums)
    print(set_nums)
remove_dups(nums)

--------------------------------------------------------------

If next number is same, add to the dict
nums = [1,2,3,3,23,2,3,1]
def remove_dups(nums):
    new_list_dict = {}
    for i in range(len(nums)-1):
        count=0
        if nums[i]==nums[i+1]:
            count+=1
            new_list_dict[nums[i]]=count
    print(new_list_dict)
remove_dups(nums)

--------------------------------------------------------------

def invert_dict(dict):
    inv_dict={}
    for k,v in dict.items():
        inv_dict[v] = k
    print(inv_dict)
invert_dict(dict1)

--------------------------------------------------------------

sentence = "a a b b c c d d e f"
list_words = sentence.split(" ")
print(list_words)
a = list(map(lambda x:(x,1),list_words))
print(a)

print("="*30)

from functools import reduce
result = reduce(
    lambda acc, item: acc.update({item[0]: acc.get(item[0], 0) + item[1]}) or acc,
    data,
    {}
)

# Convert to list of tuples
print(list(result.items()))

---------------------------------------------------------------
# Factorial of a number --
-- Using Iteration
def factorial(n):
    fact = 1
    while n >0:
        fact= fact * n
        n= n-1
    print(fact)

--Using Recursion 
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
    
print(factorial(5))

------------------------------------------------------------------

20. Leetcode: Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

My first solution -- 
Counting number of pairs of brackets and if they are same - Valid else Invalid --
-- It is not true for order of brackets requirement..

s = "{[}]()"

def isValid(s):
    dict = { '{':'}', '(':')', '[':']'}
    my_dict = {}
    # count of each element in string of brackets
    for item in s:
        my_dict[item] = s.count(item)
    #print(my_dict)
    # If count of each key of dict and value of dict is same, return true else false
    if all(my_dict[key] == my_dict[value] for key, value in dict.items()):
        print(" s is a valid string")
    else:
        print("s is not a valid string")
                
isValid(s)


 

     



