Python --
Basic functions in Python --
1. Map - It takes a function and a list as an argument. It returns an iterator, not a list.
You need to consume the iterator (e.g., with list(), for loop, etc.) to see the actual values.
This design is intentional for performance and memory efficiency.

An iterator in Python is an object that represents a stream of data. 
You can loop through it, but it doesn't hold all the data in memory at once. Instead, it generates each item on demand.

list1 = [1,2,3,4]
a = map(lambda x: (x,1),list1)
print(a) -- map object at a0xx
print(list(a)) -- [ (1,1),(2,1)..]

2. Split - The split() function in Python is used to divide a string into a list of substrings based on a specified delimiter.
The output is a list.
sentence = "A black browm fox jumps over a lazy dog"
words = sentence.split()
print(words)
['A', 'black', 'browm', 'fox', 'jumps', 'over', 'a', 'lazy', 'dog']

3. Reduce - The reduce takes a function and a list as an input and returns a reduced output. 
from functools import reduce
list1 =[1,2,3,4]
b= reduce(lambda x,y : x*y,list1)
print(b) --24
print(type(b)) --class int

4. Filter -The filter() function in Python takes in a function and a list as arguments. 
This offers an elegant way to filter out all the elements of a sequence "sequence", for which the function returns True.
a = [1,2,3,4,5]
even = filter(lambda x : x%2 ==0, a)
print(list(even))
[2,4]
==================================================
## LIST 
Accessing elements of a List #

# Use Case	              # Method
Access a specific item	  list[index]
Loop through all items	  for item in list:
Need index and value	  for i, item in enumerate(list):
Filter items	          Use if inside loop

#Method	           #Description	                             #Example
append(x)	       Adds an item to the end	                 fruits.append("orange")
extend(iterable)   Adds all items from another list	         fruits.extend(["grape", "melon"])
insert(i, x)	   Inserts item at index i	                 fruits.insert(1, "kiwi")
remove(x)	       Removes first occurrence of x	         fruits.remove("banana")
pop([i])	       Removes and returns item at index i       fruits.pop()
                   (last if not given)	
clear()	           Removes all items	                     fruits.clear()
index(x)	       Returns index of first occurrence of x	 fruits.index("apple")
count(x)	       Counts how many times x appears	         fruits.count("apple")
sort()	           Sorts the list in place	                 fruits.sort()
reverse()	       Reverses the list in place	             fruits.reverse()
copy()	           Returns a shallow copy	                 new_list = fruits.copy()

fruits = ['apple', 'banana', 'cherry']
print(fruits[0])  # Output: apple
print(fruits[2])  # Output: cherry

for fruit in fruits:
    if 'a' in fruit:
        print(fruit)

for i, fruit in enumerate(fruits):
    print(f"Index {i}: {fruit}")
 # Output: apple
 # Output: banana

for i in range(len(fruits)):
    print(f"Index {i}: {fruits[i]}")
-------------------------------------------------
Move all zeros in a list to the end while maintaining the order of non-zero elements. 
[0, 1, 0, 3, 12] to [1, 3, 12, 0, 0]

list_nums = [0, 1, 0, 3, 12]
new_list_nums=[]
count = 0
for num in list_nums:
    if num != 0:
        new_list_nums.append(num)
    else:
        count +=1
for i in range(count):
    new_list_nums.append(0)
print(new_list_nums)
-------------------------------------------------
new_list_nums = [num for num in list_nums if num != 0]
new_list_nums += [0] * list_nums.count(0)
print(new_list_nums)
--------------------------------------------------
nums = [1, 6, 3, 2, 9]
is_sorted = True
for i in range(1, len(nums)):
    if nums[i] <= nums[i - 1]:
        is_sorted = False
        break
print(is_sorted)
==================================================
## TUPLES -A tuple is an immutable, ordered collection of elements in Python. You define it using parentheses ().
Tuples use less memory than lists and are slightly faster for iteration.
#Feature	 #Tuple
Mutable	    ❌ No
Ordered	    ✅ Yes
Methods	    count(), index()
Use Cases	Fixed data, function returns, dictionary keys, memory efficiency

#Operation	  #Example	          #Description
Indexing	  t[0]	              Access element by position
Slicing	      t[1:3]	          Get a sub-tuple
Length	      len(t)	          Number of elements
Membership	  2 in t	          Check if value exists
Iteration	  for x in t:	      Loop through elements
Nesting	      ((1, 2), (3, 4))    Tuples inside tuples

1. count(value) : Returns the number of times a value appears.
t = (1, 2, 2, 3)
t.count(2)  # Output: 2
2. index(value) : Returns the first index of the value.
t.index(3)  # Output: 3

print(t[0:2])  # Output: (1,2,2)

marks = (85, 90, 85, 92, 85)
1. print( marks.count(85))
2.count = 0
for mark in marks:
    if mark == 85:
        count +=1
print(count)

--Unpacking 
def get_user():
    return ("Govind", "Lead Data Engineer")
name, role = get_user()



==================================================
## DICTIONARY 

Method	                      Description	                                    Example
get(key, default)	          Returns value for key, or default if not found	employee.get("name", "Unknown")
keys()	                      Returns all keys	                                employee.keys()
values()	                  Returns all values	                            employee.values()
items()	                      Returns all key-value pairs as tuples	            employee.items()
update(dict)	              Adds or updates key-value pairs	                employee.update({"location": "Bengaluru"})
pop(key)	                  Removes key and returns its value	                employee.pop("role")
popitem()	                  Removes and returns last inserted key-value pair	employee.popitem()
clear()	                      Removes all items	                                employee.clear()
setdefault(key, default)	  Sets value if key not present                  	employee.setdefault("team", "Data")
copy()	                      Returns a shallow copy	                        new_emp = employee.copy()

students = [
    {'name': 'Ravi', 'marks': 85},
    {'name': 'Anita', 'marks': 92},
    {'name': 'Kumar', 'marks': 78}
]

names = []
count = 0

# get method

for student in students:
    if student.get('marks') > 80:
       names.append(student.get('name'))
       count += 1
print(set(names))
print(count)

# Items method 

student1 = {'name': 'Ravi', 'age': 21, 'grade': 'A'}
student1_list = student1.items()
print(student1_list)
for k,v in student1.items():
    print(f"{ k } : { v }")

# isinstance method -- checks the datatype 
if isinstance(v, str):
     print(v)

cust_details = {
    'name': 'hello',
    'id': '123',
    'address': [
        {'street': 'abc', 'city': 'bangalore', 'state': 'ka'},
        {'street': 'abc', 'city': 'mumbai', 'state': 'mh'}
    ]
}

# Loop through the list of addresses
for addr in cust_details['address']:
    if addr['state'] == 'mh':
        print(addr)

# adding two dictionaries
dict1 = {'Virat': 10, 'Sachin': 20, 'Dhoni': 30}
dict2 = {'Virat': 15, 'Smritika': 5, 'Dhoni': 25}

result_dict = dict1.copy()
for key,value in dict2.items():
    if key in result_dict:
        result_dict[key]+=value
    else:
        result_dict[key]=value
print(result_dict)

# dict(...) converts this list of tuples into a dictionary. But if a key appears multiple times, only the last occurrence is kept.
word = ['a','e','i','o','u','a','e','i','k']
list_words = dict(map(lambda x: (x,1), word))
print(list_words)
output --{'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'k': 1}
So 'a' appears twice, but only the last ('a', 1) is retained. Same for 'e' and 'i'.

# Counting the frequency of words in a list and return a dict with word,count --
word = ['a','e','i','o','u','a','e','i','k']
list_words = {}

for char in word:
    if char in list_words:
        list_words[char] += 1
    else:
        list_words[char] = 1

print(list_words)

==================================================

## FUNCTIONS --

Global Variable Inside Function - Modification 
Read global variable	                   ✅ Allowed without global keyword
Assign to global variable	               ❌ Not allowed unless declared with global
Assign inside function without global	   Python treats it as a new local variable

x = "global"
def fun():
    double = x * 2
    print(double)
fun() 

--x is defined outside the function, so it's a global variable. Inside fun(), you're readingx, not modifying it.
Python allows reading global variables inside functions without any special declaration. x * 2 just duplicates the string: "globalglobal"

x = "global"

def fun():
    x = x * 2
    print(x)

fun()

You're trying to assign to x inside the function: x = x * 2
Python treats any variable assigned inside a function as local by default.
So it thinks you're creating a new local variable x, but then tries to use its value (x * 2) before it's defined.
Since there's no local x yet, Python throws an UnboundLocalError.

x = "global"

def fun():
    global x
    x = x * 2
    print(x)

fun()

When we declare with global keyword, it creates a local copy of the global variable.



-----------------------------------------------------------------
list_nums = [12,12,34,55,67,88,89,85]
list_rev=[]

# Reverse List elements
def rev_list(nums):
    for i in range(len(nums)):
        list_rev.append(nums[-i])
rev_list(list_nums)
print(list_rev)

def rev_list(nums):
  return nums[::-1]
print(rev_list(list_nums))

def even_sum(nums):
    even_nums=[]
    len_nums=len(nums)
    for i in range(len_nums):
        if nums[i]%2==0:
            even_nums.append(nums[i])
    return sum(even_nums)

even_sum(list_nums)

even_sum = lambda nums: sum(num for num in nums if num % 2 == 0)
even_sum(list_nums)

len_list = len(list_nums_1)

==================================================
# Remove duplicates from a list
def remove_dup(nums):
    i=0
    while i < len_list-1:
        if list_nums[i]==list_nums[i+1]:
            list_nums.remove(list_nums[i+1])
        else:
            i+=1
    return list_nums

remove_dup(list_nums)
==================================================

def squared_nums(nums):
    squared_nums=[]
    for num in nums:
        squared_nums.append(num**2)
    return squared_nums
squared_nums(list_nums_1)

==================================================
list_1 = [1,2,3,4,5,6,7,8,9,10]
k=2
# Break the list in 2 parts at kth elements from last and then merge the list
def rotate_list(nums,k):
    list1 = nums[:len(nums)-k]
    list2 = nums[len(nums)-k:]
    return list2 + list1
rotate_list(list_1,k)


def rotate_list(nums,k):
    return nums[len(nums)-k:] + nums[:len(nums)-k]
rotate_list(list_1,k)

==================================================

#Count the number of vowels in a given string.
word = 'AnkitaRiya'
def count_vowels(word):
    vowels = ['a','e','i','o','u','A','E','I','O','U']
    count = 0
    for char in word:
        if char in vowels:
            count += 1
    return count
count_vowels(word)

==================================================

#Reverse the string without using slicing.
word = 'AnkitaRiya'
def reverse_string(word1,word2):
    reversed_string=""
    reversed_string1=""
    print(word)
    for char in word:
        reversed_string = char + reversed_string
        reversed_string1 = reversed_string1 + char
    return reversed_string,reversed_string1

reverse_string(word,word)

==================================================

#Write a function to find the first non-repeating character in a string. If all characters repeat, return None.
def first_non_repeating_character(string):
    repeat_char=[]
    non_repeat_char=[]
    for char in string:
        if string.count(char) > 1:
            repeat_char.append(char)
        else:
            non_repeat_char.append(char)
    
    if len(non_repeat_char) == 0:
        return None
    else:
        return non_repeat_char[0]
    
first_non_repeating_character(word)


========================================================================================================================================================================================================

dict1 = { 'key1' : 2000, 'key2' : 3000, 'key3' : 5000}
dict2 = { 'key1' : 1000, 'key2' : 2000}


def merge_dict(dict1,dict2):
  result_dict = dict1.copy()
  for k,v in dict2.items():
    if k in result_dict:
        result_dict[k] += v
    else:
        result_dict[k] = v
  return result_dict
a = merge_dict(dict1,dict2)

--------------------------------------------------------------

nums = [1,2,3,3,23,2,3,1]
def remove_dups(nums):
    set_nums = set(nums)
    print(set_nums)
remove_dups(nums)

--------------------------------------------------------------

If next number is same, add to the dict
nums = [1,2,3,3,23,2,3,1]
def remove_dups(nums):
    new_list_dict = {}
    for i in range(len(nums)-1):
        count=0
        if nums[i]==nums[i+1]:
            count+=1
            new_list_dict[nums[i]]=count
    print(new_list_dict)
remove_dups(nums)

--------------------------------------------------------------

def invert_dict(dict):
    inv_dict={}
    for k,v in dict.items():
        inv_dict[v] = k
    print(inv_dict)
invert_dict(dict1)

--------------------------------------------------------------

sentence = "a a b b c c d d e f"
list_words = sentence.split(" ")
print(list_words)
a = list(map(lambda x:(x,1),list_words))
print(a)
print("="*30)
from functools import reduce
result = reduce(
    lambda acc, item: acc.update({item[0]: acc.get(item[0], 0) + item[1]}) or acc,
    data,
    {}
)

# Convert to list of tuples
print(list(result.items()))

---------------------------------------------------------------






     



