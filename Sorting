------------------------------------------------------------------------------------
1. Bubble Sort --
------------------------------------------------------------------------------------
-- It works like a wave of bubbles pushing the largest element to the right most side after each outer iteration.
-- The inner loop compares through adjacent elements for the entire stretch of the outer iteration

A = [1,2,3,454,5,65,9]

def sortArray(A):
    for i in range(1,len(A)):
        for j in range(1,len(A)):
            if A[j-1] > A[j]:
               tmp= A[j-1]
               A[j-1]=A[j]
               A[j] = tmp
        print(A)
sortArray(A)

def sortArray(A):
    size = len(A)
    for i in range(size-1):
        for j in range(size-1-i):
            if A[j] > A[j+1]:
               tmp= A[j]
               A[j]=A[j+1]
               A[j+1] = tmp
        print(A)
sortArray(A)

-- optimised as if array gets sorted in one iteration, it breaks the loop -- O(n)
def sortArray(A):
    for i in range(1,len(A)):
        swapped = False
        for j in range(1,len(A)):
            if A[j-1] > A[j]:
               tmp= A[j-1]
               A[j-1]=A[j]
               A[j] = tmp
               swapped =True
        if not swapped:
            break
        print(A)
sortArray(A)


Exercise -- --------------------------------------------------------------------------------

bubble_sort function should take key from a transaction record and sort the list as per that key. 
For example,bubble_sort(elements, key='transaction_amount')
Apply over this list of dictionary 

A = [
        { 'name': 'mona',   'transaction_amount': 1000, 'device': 'iphone-10'},
        { 'name': 'dhaval', 'transaction_amount': 400,  'device': 'google pixel'},
        { 'name': 'kathy',  'transaction_amount': 200,  'device': 'vivo'},
        { 'name': 'aamir',  'transaction_amount': 800,  'device': 'iphone-8'},
    ]


def sortArray(A,key='transaction_amount'):
    for i in range(1,len(A)):
        swapped = False
        for j in range(1,len(A)):
            if A[j-1][key] > A[j][key]:
               tmp= A[j-1]
               A[j-1]=A[j]
               A[j] = tmp
               swapped =True
        if not swapped:
            break
        print(A)
sortArray(A)

-- swapped in single line 

def sortArray(A, key='transaction_amount'):
    for i in range(1, len(A)):
        swapped = False
        for j in range(1, len(A)):
            if A[j-1][key] > A[j][key]:
                A[j-1], A[j] = A[j], A[j-1]
                swapped = True
        if not swapped:
            break
        print(f"After pass {i}: {A}")
        
------------------------------------------------------------------------------------
2. QUICK SORT 
------------------------------------------------------------------------------------

# implementation of quick sort in python using hoare partition scheme

def swap(a, b, arr):
    if a!=b:
        tmp = arr[a]
        arr[a] = arr[b]
        arr[b] = tmp

def quick_sort(elements, start, end):
    if start < end:
        pi = partition(elements, start, end)
        quick_sort(elements, start, pi-1)
        quick_sort(elements, pi+1, end)

def partition(elements, start, end):
    pivot_index = start
    pivot = elements[pivot_index]

    while start < end:
        while start < len(elements) and elements[start] <= pivot:
            start+=1

        while elements[end] > pivot:
            end-=1

        if start < end:
            swap(start, end, elements)

    swap(pivot_index, end, elements)

    return end


if __name__ == '__main__':
    elements = [11,9,29,7,2,15,28]
    # elements = ["mona", "dhaval", "aamir", "tina", "chang"]
    quick_sort(elements, 0, len(elements)-1)
    print(elements)

    tests = [
        [11,9,29,7,2,15,28],
        [3, 7, 9, 11],
        [25, 22, 21, 10],
        [29, 15, 28],
        [],
        [6]
    ]

    for elements in tests:
        quick_sort(elements, 0, len(elements)-1)
        print(f'sorted array: {elements}')

=====================================================================================
