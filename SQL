SQL Concepts --

SQL Operations - FROM > JOIN > WHERE > GROUP BY > HAVING > SELECT > ORDER BY


Use case --
Finding duplicates   -- row number 

WITH ranked_visits AS (
  SELECT *,
         ROW_NUMBER() OVER (PARTITION BY user_id, visit_date ORDER BY user_id) AS rnk
  FROM user_visits
)
DELETE FROM user_visits
WHERE user_id IN (
  SELECT user_id FROM ranked_visits WHERE rnk > 1
);


Third highest salary -- dense_rank
  -- if we use rank we may miss some f the valid records due to hole between ranks

1. ROW_NUMBER()
Use Case: Assigns a unique sequential number to each row within a partition.
Best for: When you need unique row identifiers or want to filter duplicates.
Example: Get the latest record per user.

SELECT * FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) AS rn
  FROM user_activity
) t
WHERE rn = 1;


üìä Business Intelligence & Reporting

Paginated reports: Assign row numbers to enable pagination in dashboards.
Deduplication: Identify and keep only the first occurrence of a record based on some criteria.
Audit trails: Track the sequence of events or changes per entity.

üßÆ Data Engineering & ETL

Surrogate key generation: Create unique IDs for staging tables.
Change Data Capture (CDC): Identify latest record per key in slowly changing dimensions.

üõí E-commerce & Retail

Latest transaction per user: Identify most recent purchase or cart update.
Product listing order: Assign display order for products.

üè¶ Finance

Transaction tracking: Identify first or last transaction per account.
Fraud detection: Flag unusual patterns by comparing row sequences.

üèÖ 2. RANK()
Use Case: Assigns a rank to rows within a partition, with gaps in ranking when there are ties
Best for: When you want to preserve ranking gaps for tied values.
Example: Rank students by score, allowing gaps for ties.
SELECT student_id, score,
       RANK() OVER (ORDER BY score DESC) AS rank
FROM exam_results;
If two students tie for 1st place, the next rank will be 3 (not 2).

Top-N analysis with ties: Show top 5 performing stores, allowing multiple stores to share the same rank.
Sales competitions: Rank sales reps where ties matter and gaps are expected.

Data deduplication with priority: Rank duplicate rows based on timestamp or priority column.
Partitioned ranking: Rank within groups (e.g., per region, per category) during transformations.

Best-selling products: Rank products by sales volume.
Customer loyalty: Rank customers by lifetime value or frequency.

üßë‚Äçüè´ Education & Exams

Exam results: Rank students by score, allowing for tied ranks.
Scholarship eligibility: Select top performers with clear rank gaps.

Portfolio performance: Rank assets by ROI.
Credit scoring: Rank borrowers based on risk metrics.

ü•à 3. DENSE_RANK()
Use Case: Similar to RANK(), but no gaps in ranking for ties.
Best for: When you want continuous ranking even with ties.
Example: Rank products by sales, without skipping ranks.

DENSE_RANK()

Tiered segmentation: Group customers into tiers (e.g., Gold, Silver, Bronze) based on purchase volume without gaps.
Product categorization: Rank products by popularity for recommendation systems.

Grade assignment: Assign grades based on score bands without skipping ranks.

SELECT product_id, total_sales,
       DENSE_RANK() OVER (ORDER BY total_sales DESC) AS rank
FROM product_sales;

If two products tie for 1st place, the next rank will be 2.


Question Leetcode --

We are given a table called UserVisits which contains logs of the dates that users visited a specific retailer. The table has two columns user_id and visit_date. 
We have to write an SQL query to find out the largest window of days between each visit and the one right after it (or today if we are considering the last visit)
for each user_id. We return the result table ordered by user_id.


INSERT INTO user_visits(user_id, visit_date)
VALUES 
  (1, '2020-11-28'),
  (1, '2020-10-20'),
  (1, '2020-12-03'),
  (2, '2020-10-05'),
  (2, '2020-12-09'),
  (3, '2020-11-11');


select 
user_id,
days_until_next_visit
from  
 (
 select 
 user_id,
 days_until_next_visit,
 dense_rank() over (partition by user_id order by days_until_next_visit desc) as rnk 
 from 
   (  SELECT
    user_id,
    ROUND(julianday(LEAD(visit_date, 1, '2021-01-01') OVER (PARTITION BY user_id ORDER BY visit_date)) - julianday(visit_date)) AS days_until_next_visit
    FROM user_visits
   )
 ) where rnk=1
;

user_id	  days_until_next_visit
1	        39
2	        65
3	        51

-- optimised query


WITH visit_gaps AS (
  SELECT
    user_id,
    ROUND(julianday(LEAD(visit_date, 1, '2021-01-01') OVER (PARTITION BY user_id ORDER BY visit_date)) - julianday(visit_date)) AS days_until_next_visit
  FROM user_visits
),
max_gaps AS (
  SELECT 
    user_id,
    days_until_next_visit,
    DENSE_RANK() OVER (PARTITION BY user_id ORDER BY days_until_next_visit DESC) AS rnk
  FROM visit_gaps
)
SELECT 
  user_id,
  days_until_next_visit
FROM max_gaps
WHERE rnk = 1;




üß† Summary Table

Function         Gaps in Rank      Unique per Row     Common Use Case
ROW_NUMBER()     ‚ùå No‚úÖ          Yes                Deduplication, pagination
RANK()           ‚úÖ Yes           ‚ùå                 NoCompetition-style ranking with gaps
DENSE_RANK()     ‚ùå No            ‚ùå                 NoGrouped ranking without gaps


# Join with Ranking for top 3 highest salaries in dept --
WITH ranked_employees as (
select e.emp_id, e.emp_name, e.dept_id, d.name, e.salary,
dense_rank() over (partition by e.dept_id order by e.salary) as rnk
from employees e
join department d 
on e.dept_id=d.id )
select emp_id, emp_name, dept_id, salary from ranked_employees
where rnk <= 3;

# Managers having at least 5 direct reports --
select emp_name from employees where emp_id in (
  select manager_id from employees group by manager_id having count(*) > 5 )

# Delete duplicates from table --
with duplicated_records as (
select *, row_number() over ( order by emp_id ) as rnk from employees )

DELETE from duplicated_records where rnk > 1

# Last Person to fit in the Bus --
WITH total_weight_by_turn as (
select person_name, sum(weight) over (order by turn) as total_weight from queue )
select person_name from total_weight_by_turn where total_weight <= 1000 order by total_weight DESC limit 1

# Transactions count and amount if approved from transactions table grouped by month and country
select date_format('trans_date' , '%Y-%M') as month,
country,
EXTRACT(YEAR from trans_date) as year,
EXTRACT(MONTH from trans_date) as month,
sum(case when status='approved' then 1 else 0 end) as approved_count,
sum(amount) as total_trans_amount,
sum(case when status="approved" then amount else 0 end) as approved_trans_amount
from transactions 
where EXTRACT(YEAR from trans_date) = 2024 
group by year, month, country

# 7 day moving average of daily sales revenue --
select prod_id, date, revenue, avg(revenue) over (partition by prod_id order by date rows between 6 PRECEDING and CURRENT ROW)
AS '7_days_moving_avg'
from sales_data
order by prod_id, date

# Organisation Tree
--Starts a recursive CTE named Org_chart. This allows the query to call itself to build hierarchical data.
--Base case
WITH RECURSIVE Org_chart as (
select emp_id, emp_name, manager_id, 0 as level from emp where manager_id is null
union all    --is used to keep duplicates
--recursive part:
select e.emp_id, e.emp_name, e.manager_id, oc.level + 1 from employees e join Orgchart oc on e.manager_id = oc.emp_id 
)
select * from Orgchart order by level, emp_id

#  Best emp, best client by dept id --

-- create table emp_details( emp_id INT, emp_name VARCHAR, dept_id INT);

--insert into emp_details (emp_id,emp_name,dept_id) 
--Values
--(101,'ALice',1),
--(102,'Bob',1),
--(103,'Carol',2),
--(104,'David',2)

--create table emp_sales(emp_id INT, client_id INT, sales INT)

--insert into emp_sales(emp_id,client_id,sales)
--VALUES
--(101,201,5000),
--(101,202,3000),
--(102,201,7000),
--(103,202,6000),
--(104,203,8000)

Emp_details
emp_id	emp_name	dept_id
101	ALice	1
102	Bob	1
103	Carol	2
104	David	2


Emp_sales
emp_id	client_id	sales
101	201	5000
101	202	3000
102	201	7000
103	202	6000
104	203	8000


# Solution --
select dept_id, 
max(case when client_rank = 1 then client_id else 0 end) as best_client_id,
max(case when emp_rank = 1 then emp_id else 0 end) as best_emp_id
from 
(
with max_emp_sales as ( 
  select emp_id,sum(sales) as sales from emp_sales group by emp_id),
max_client_sales as (
  select client_id,sum(sales) as sales from emp_sales group by client_id)

select d.dept_id,d.emp_id,s.client_id ,m.sales client_sales ,e.sales emp_sales,
dense_rank() over (partition by d.dept_id order by m.sales desc) as client_rank,
dense_rank() over (partition by d.dept_id order by e.sales desc) as emp_rank
from emp_details d
join emp_sales s
on d.emp_id = s.emp_id
join max_emp_sales e
on e.emp_id = s.emp_id
join max_client_sales m
on s.client_id = m.client_id
)
group by dept_id

# Output
dept_id	best_client_id	best_emp_id
1	201	101
2	202	104

-- Use meanigful aliases, single CTE, avoid repeated aggregation, use nulls in place of zeros, row number instead of dense rank,
# Optimised --

WITH emp_sales_agg AS (
  SELECT emp_id, client_id, SUM(sales) AS total_sales
  FROM emp_sales
  GROUP BY emp_id, client_id
),
emp_totals AS (
  SELECT emp_id, SUM(total_sales) AS emp_sales
  FROM emp_sales_agg
  GROUP BY emp_id
),
client_totals AS (
  SELECT client_id, SUM(total_sales) AS client_sales
  FROM emp_sales_agg
  GROUP BY client_id
),
ranked AS (
  SELECT 
    ed.dept_id,
    ed.emp_id,
    esa.client_id,
    ct.client_sales,
    et.emp_sales,
    ROW_NUMBER() OVER (PARTITION BY ed.dept_id ORDER BY ct.client_sales DESC) AS client_rank,
    ROW_NUMBER() OVER (PARTITION BY ed.dept_id ORDER BY et.emp_sales DESC) AS emp_rank
  FROM emp_details ed
  JOIN emp_sales_agg esa ON ed.emp_id = esa.emp_id
  JOIN emp_totals et ON et.emp_id = esa.emp_id
  JOIN client_totals ct ON ct.client_id = esa.client_id
)
SELECT 
  dept_id,
  MAX(CASE WHEN client_rank = 1 THEN client_id ELSE NULL END) AS best_client_id,
  MAX(CASE WHEN emp_rank = 1 THEN emp_id ELSE NULL END) AS best_emp_id
FROM ranked
GROUP BY dept_id;


Questions --
Question: For each department, find the top 3 employees based on total sales. Include their rank and total sales.
Question: Assign percentile ranks to employees based on their total sales across all departments.
Question: Find the client who has made purchases in the most number of distinct months. Return client ID and count of months.
Question: For each employee, calculate their percentage contribution to the total sales of their department.
Question: For each employee, find the date of their first and last sale.
Question: For each employee, calculate a 3-month rolling sum of sales.
Question: Identify employees whose sales in any month were more than 2x their average monthly sales.
Question: Find clients who made purchases in consecutive months at least 3 times.
Question: For each department, find:
  Total sales
  Number of employees
  Average sales per employee
  Best performing employee
Question: Suppose you have stages like lead, contacted, demo, closed. For each stage, 
          count how many clients reached it and calculate conversion rate to the next stage.


