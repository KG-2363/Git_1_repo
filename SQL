SQL Concepts --

SQL Operations - FROM > JOIN > WHERE > GROUP BY > HAVING > SELECT > ORDER BY

# Join with Ranking for top 3 highest salaries in dept --
WITH ranked_employees as (
select e.emp_id, e.emp_name, e.dept_id, d.name, e.salary,
dense_rank() over (partition by e.dept_id order by e.salary) as rnk
from employees e
join department d 
on e.dept_id=d.id )
select emp_id, emp_name, dept_id, salary from ranked_employees
where rnk <= 3;

# Managers having at least 5 direct reports --
select emp_name from employees where emp_id in (
  select manager_id from employees group by manager_id having count(*) > 5 )

# Delete duplicates from table --
with duplicated_records as (
select *, row_number() over ( order by emp_id ) as rnk from employees )

DELETE from duplicated_records where rnk > 1

# Last Person to fit in the Bus --
WITH total_weight_by_turn as (
select person_name, sum(weight) over (order by turn) as total_weight from queue )
select person_name from total_weight_by_turn where total_weight <= 1000 order by total_weight DESC limit 1

# Transactions count and amount if approved from transactions table grouped by month and country
select date_format('trans_date' , '%Y-%M') as month,
country,
EXTRACT(YEAR from trans_date) as year,
EXTRACT(MONTH from trans_date) as month,
sum(case when status='approved' then 1 else 0 end) as approved_count,
sum(amount) as total_trans_amount,
sum(case when status="approved" then amount else 0 end) as approved_trans_amount
from transactions 
where EXTRACT(YEAR from trans_date) = 2024 
group by year, month, country

# 7 day moving average of daily sales revenue --
select prod_id, date, revenue, avg(revenue) over (partition by prod_id order by date rows between 6 PRECEDING and CURRENT ROW)
AS '7_days_moving_avg'
from sales_data
order by prod_id, date

# Organisation Tree
--Starts a recursive CTE named Org_chart. This allows the query to call itself to build hierarchical data.
--Base case
WITH RECURSIVE Org_chart as (
select emp_id, emp_name, manager_id, 0 as level from emp where manager_id is null
union all    --is used to keep duplicates
--recursive part:
select e.emp_id, e.emp_name, e.manager_id, oc.level + 1 from employees e join Orgchart oc on e.manager_id = oc.emp_id 
)
select * from Orgchart order by level, emp_id

#  Best emp, best client by dept id --

-- create table emp_details( emp_id INT, emp_name VARCHAR, dept_id INT);

--insert into emp_details (emp_id,emp_name,dept_id) 
--Values
--(101,'ALice',1),
--(102,'Bob',1),
--(103,'Carol',2),
--(104,'David',2)

--create table emp_sales(emp_id INT, client_id INT, sales INT)

--insert into emp_sales(emp_id,client_id,sales)
--VALUES
--(101,201,5000),
--(101,202,3000),
--(102,201,7000),
--(103,202,6000),
--(104,203,8000)

Emp_details
emp_id	emp_name	dept_id
101	ALice	1
102	Bob	1
103	Carol	2
104	David	2


Emp_sales
emp_id	client_id	sales
101	201	5000
101	202	3000
102	201	7000
103	202	6000
104	203	8000


# Solution --
select dept_id, 
max(case when client_rank = 1 then client_id else 0 end) as best_client_id,
max(case when emp_rank = 1 then emp_id else 0 end) as best_emp_id
from 
(
with max_emp_sales as ( 
  select emp_id,sum(sales) as sales from emp_sales group by emp_id),
max_client_sales as (
  select client_id,sum(sales) as sales from emp_sales group by client_id)

select d.dept_id,d.emp_id,s.client_id ,m.sales client_sales ,e.sales emp_sales,
dense_rank() over (partition by d.dept_id order by m.sales desc) as client_rank,
dense_rank() over (partition by d.dept_id order by e.sales desc) as emp_rank
from emp_details d
join emp_sales s
on d.emp_id = s.emp_id
join max_emp_sales e
on e.emp_id = s.emp_id
join max_client_sales m
on s.client_id = m.client_id
)
group by dept_id

# Output
dept_id	best_client_id	best_emp_id
1	201	101
2	202	104

-- Use meanigful aliases, single CTE, avoid repeated aggregation, use nulls in place of zeros, row number instead of dense rank,
# Optimised --

WITH emp_sales_agg AS (
  SELECT emp_id, client_id, SUM(sales) AS total_sales
  FROM emp_sales
  GROUP BY emp_id, client_id
),
emp_totals AS (
  SELECT emp_id, SUM(total_sales) AS emp_sales
  FROM emp_sales_agg
  GROUP BY emp_id
),
client_totals AS (
  SELECT client_id, SUM(total_sales) AS client_sales
  FROM emp_sales_agg
  GROUP BY client_id
),
ranked AS (
  SELECT 
    ed.dept_id,
    ed.emp_id,
    esa.client_id,
    ct.client_sales,
    et.emp_sales,
    ROW_NUMBER() OVER (PARTITION BY ed.dept_id ORDER BY ct.client_sales DESC) AS client_rank,
    ROW_NUMBER() OVER (PARTITION BY ed.dept_id ORDER BY et.emp_sales DESC) AS emp_rank
  FROM emp_details ed
  JOIN emp_sales_agg esa ON ed.emp_id = esa.emp_id
  JOIN emp_totals et ON et.emp_id = esa.emp_id
  JOIN client_totals ct ON ct.client_id = esa.client_id
)
SELECT 
  dept_id,
  MAX(CASE WHEN client_rank = 1 THEN client_id ELSE NULL END) AS best_client_id,
  MAX(CASE WHEN emp_rank = 1 THEN emp_id ELSE NULL END) AS best_emp_id
FROM ranked
GROUP BY dept_id;



